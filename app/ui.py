# UI for the agent using ChainLit framework to make a chat window.
import chainlit as cl

from datetime import datetime
import sys
import os

# Get the absolute path of the current script's directory (app/)
current_dir = os.path.dirname(os.path.abspath(__file__))
# Get the parent directory (CollegeInfoBot/)
root_dir = os.path.dirname(current_dir)

# Add the root directory to sys.path so 'tools' can be found
if root_dir not in sys.path:
    sys.path.append(root_dir)
from tools.doc_generator import create_admission_report 
import httpx
"""
Set up the directory to save the output file generated by the agent.
"""
OUTPUT_DIR=os.path.join(os.getcwd(),"outputs")
os.makedirs(OUTPUT_DIR,exist_ok=True)

"""
Below contains the initial message the chat-bot sends the users way. 
It includes greetings, introduction of the bot and the details which the bot needs.
"""
@cl.on_chat_start
async def start():
    await cl.Message(
        content="Hello dear aspirant, I am your college advisor, here to help you.\n\n"
                "Tell me the details of the university you are targeting:\n"
                "* **University Name**\n"
                "* **Program Name**\n"
                "* **Level of study** (Bachelors, Masters, PhD)\n"
                "* **Background** (GPAm Country, College Tier etc.)\n"
                "When you provide me this information I will provide you with a document that comprises of strategy and information on the course you are aiming for!"
    ).send()

"""
Determines the steps after user responds with information. 
"""
@cl.on_message
async def main(message: cl.Message):
    # STEP 1: Extract the name of uni and the program name
    async with cl.Step(name="Identifying Target", type="tool") as step:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://127.0.0.1:8001/run-agent",
                json={"message": message.content},
                timeout=30  # Give LLM time to think
            )
            
            if response.status_code == 200:
                data = response.json()
                uni_name = data.get("university", "Unknown University")
                program_name = data.get("program", "Unknown Program")
                level=data.get("level","Bachelors")
                
                # Save data to session
                cl.user_session.set("uni", uni_name)
                cl.user_session.set("program", program_name)
                cl.user_session.set("level", level)

                # Format the UI output
                clean_name = f"{uni_name}-{program_name}".replace(" ", "-")
                step.output = f"Targeting: {uni_name} ({program_name})"
            

            else:
                step.output = "Error: Could not extract university details."
                return


    # STEP 2: Document generation
    async with cl.Step(name="Strategist Agent", type="run") as agent_step:
        # 1. Prepare data for the API
        research_data = {
            "university": cl.user_session.get("uni"),
            "program": cl.user_session.get("program"),
            "level": cl.user_session.get("level"),
            "background": message.content # Sending full user bio as context
        }

        # 2. Call the Agentic Kickoff endpoint
        async with httpx.AsyncClient() as client:
            # We increase timeout because scraping + reasoning takes time
            res = await client.post(
                "http://127.0.0.1:8001/start-research",
                json=research_data,
                timeout=180 
            )
            if res.status_code == 200:
                agent_data = res.json()
                report_content = agent_data.get("report", "No report generated.")
                agent_step.output = f"Strategy for {uni_name} completed."
            else:
                agent_step.output = f"Error: Agent failed to generate strategy."
                return

    # --- STEP 3: Delivery (File Generation & Upload) ---
    # Define the filename and path
    # --- STEP 3: Delivery (Docx Generation & Upload) ---
    
    # 1. Define filenames
    filename = f"{clean_name}.docx"
    file_path = os.path.join(OUTPUT_DIR, filename)

    try:
        # 2. Call your custom function to generate the Word Doc
        # Note: We pass report_content as the 'content' argument
        final_path = create_admission_report(
            university=cl.user_session.get("uni"),
            program=cl.user_session.get("program"),
            content=report_content,
            output_path=file_path
        )

        # 3. Send the file back via Chainlit
        if os.path.exists(final_path):
            await cl.Message(
                content=f"Done! I have compiled the research and strategy for **{uni_name}**. You can download your professional guide below:",
                elements=[
                    cl.File(
                        name=filename, 
                        path=final_path, 
                        display="inline"
                    )
                ]
            ).send()
            
    except Exception as e:
        await cl.Message(content=f"An error occurred while creating the Word document: {str(e)}").send()